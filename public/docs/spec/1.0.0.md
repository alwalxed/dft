# Depth-First Thinking (dft) - MVP Specification

**Version:** 1.0.0 MVP
**Tagline:** "Solve problems the depth-first way."

---

## Overview

**dft** is a terminal-based todo-list tool that manages workflows using tree structures with call-stack-inspired navigation. Users decompose complex problems into sub-problems, navigate depth-first using keyboard shortcuts, track progress, and maintain focused context. This approach leverages the Zeigarnik effect to help manage cognitive load by keeping unfinished tasks visible and structured.

### Core Philosophy

- **Depth-first navigation:** Emphasize deep exploration along a single path
- **Keyboard-driven:** All navigation and actions via arrow keys and shortcuts (no typed commands)
- **Focused context:** Always show the current problem with its children and sibling context
- **Cascading completion:** Marking a node done completes all its descendants
- **Simplicity:** Clean data model, predictable behavior, minimal API surface

---

## Technical Stack

- **Runtime:** Bun (latest stable)
- **Language:** TypeScript
- **TUI:** OpenTUI (@opentui/core)
  - Docs: `https://raw.githubusercontent.com/anomalyco/opentui/refs/heads/main/packages/core/docs/getting-started.md`
  - Examples: `https://github.com/anomalyco/opentui/tree/main/packages/core/src/examples`
- **CLI Parsing:** Commander.js or native Bun argument parsing
- **Storage:** JSON files in platform-specific data directory:
  - **macOS:** `~/Library/Application Support/depthfirst/projects/`
  - **Linux:** `$XDG_DATA_HOME/depthfirst/projects/` (fallback: `~/.local/share/depthfirst/projects/`)
  - **Windows:** `%APPDATA%\depthfirst\projects\`

---

## Data Model

### Project Schema

**Location:** `<data_dir>/depthfirst/projects/<project_name>.json`

Where `<data_dir>` is platform-specific:
- **macOS:** `~/Library/Application Support/`
- **Linux:** `$XDG_DATA_HOME` or `~/.local/share/`
- **Windows:** `%APPDATA%`

```json
{
  "project_name": "string",
  "version": "1.0.0",
  "created_at": "ISO-8601",
  "modified_at": "ISO-8601",
  "root": {
    "id": "uuid-v4",
    "title": "string",
    "status": "open|done",
    "children": [],
    "created_at": "ISO-8601",
    "completed_at": "ISO-8601|null"
  }
}
```

### Node Structure

| Field          | Type               | Constraints                  | Notes                                      |
|----------------|--------------------|------------------------------|--------------------------------------------|
| `id`           | UUID v4            | 36 characters                | Immutable, auto-generated                  |
| `title`        | String             | 1–200 characters             | Single-line, trimmed                       |
| `status`       | Enum               | `"open"` \| `"done"`         | Default: `"open"`                          |
| `children`     | Array of nodes     | 0–1000 nodes                 | Insertion order preserved                  |
| `created_at`   | ISO-8601           | Valid timestamp              | Immutable                                  |
| `completed_at` | ISO-8601 \| null   | Valid timestamp or null      | Set when `status` is `"done"`              |

### Project Naming Rules

- **Length:** 1–50 characters
- **Characters:** `a-z`, `0-9`, `-`, `_`
- **Pattern:** Must start with an alphanumeric character
- **Reserved names:** `list`, `new`, `delete`, `open`, `tree`, `help`, `version`
- **Storage:** Converted to lowercase (case-insensitive)
- **Spaces:** Not allowed
- **Case Sensitivity**: Only lowercase, and convert upppers to lowers

---

## CLI Interface

### Binary: `dft`

**Global Options:**
- `--version` – Show version
- `--help`     – Show help

### Commands

#### `dft new <project_name> <root_title>`

Create a new project with an initial root problem.

**Behavior:**
- Validates project name
- Fails if project already exists
- Creates projects directory if needed (platform-specific path)
- Generates project file with root node
- Output: `Created project '{name}' with root problem '{title}'`

**Exit Codes:** `0` (success), `1` (invalid name), `2` (already exists), `3` (filesystem error)

```bash
dft new my-app "Build authentication system"
```

---

#### `dft list`

List all projects, sorted by creation date (newest first).

**Output:**
```
Projects:
  • api-design (12 problems)
  • my-app (5 problems)
  • refactoring-plan (8 problems)
```

If none exist: `No projects found. Create one with 'dft new <name> <title>'`

**Exit Codes:** `0` (always)

---

#### `dft delete <project_name>`

Delete an existing project.

**Options:**
- `--yes` / `-y` – Skip confirmation prompt

**Behavior:**
- Confirms project exists
- Prompts for confirmation unless `--yes` is used
- Deletes the project file
- Output: `Deleted project '{name}'`

**Exit Codes:** `0` (success), `1` (not found), `2` (cancelled), `3` (filesystem error)

---

#### `dft open <project_name>` or `dft <project_name>`

Launch the interactive TUI session.

**Behavior:**
- Validates project existence
- Loads project data
- Starts OpenTUI with keyboard navigation
- Auto-saves on changes and exit

**Exit Codes:** `0` (normal), `1` (not found), `2` (corrupted), `3` (TUI error)

```bash
dft open my-app
dft my-app  # shorthand
```

---

#### `dft tree <project_name>`

Print the tree structure to stdout (non-interactive).

**Options:**
- `--show-status` – Show status markers (default: true)
- `--no-status`   – Hide status markers

**Output Example:**
```
[ ] Root Problem
  [x] Completed Sub-Problem
    [ ] Grandchild Problem
  [ ] Open Branch
    [ ] Another Level
```

**Exit Codes:** `0` (success), `1` (not found), `2` (corrupted)

---

## Interactive TUI

### Focused Mode (Single Mode)

The TUI uses a single focused mode that shows the current problem prominently with its children and sibling context. Navigation follows a depth-first, call-stack-inspired model.

```
┌─────────────────────────────────────────────────────┐
│ Root > Parent Problem                               │
├─────────────────────────────────────────────────────┤
│                                                     │
│   [OPEN] Current Problem Title                      │
│                                                     │
│   Children (3):                                     │
│     • [ ] First sub-problem                         │
│     • [x] Second sub-problem                        │
│     • [ ] Third sub-problem                         │
│                                                     │
│   ↑ Previous Sibling Title                          │
│   ↓ Next Sibling Title                              │
│                                                     │
├─────────────────────────────────────────────────────┤
│ ↑↓:siblings →:dive ←:back n:new e:edit d:done x:del│
└─────────────────────────────────────────────────────┘
```

**Display Elements:**
- **Breadcrumb bar:** Path from root to parent of current node
- **Current node:** Prominently displayed with status badge
- **Children list:** Preview of all children (if any)
- **Sibling indicators:** Shows adjacent siblings for context
- **Key hints:** Available actions

**Empty states:**
- No children: `No sub-problems yet. Press 'n' to add one.`
- No siblings above: `↑` indicator hidden
- No siblings below: `↓` indicator hidden

---

### Navigation Model

The navigation follows a **depth-first, tree-based** model:

| Direction | Key | Action | Description |
|-----------|-----|--------|-------------|
| **Up** | `↑/k` | Previous sibling | Move to previous node at same level |
| **Down** | `↓/j` | Next sibling | Move to next node at same level |
| **Right** | `→/l` | Dive deeper | Enter first child of current node |
| **Left** | `←/h` | Go shallower | Return to parent node |

**Edge Behavior:**
- At first sibling + `↑`: Flash/message "No previous sibling"
- At last sibling + `↓`: Flash/message "No next sibling"
- No children + `→`: Flash/message "No children"
- At root + `←`: Flash/message "Already at root"

**Mental Model:**
Think of it like navigating a file system:
- `←/→` = `cd ..` / `cd child` (depth)
- `↑/↓` = moving between items in `ls` output (siblings)

---

### Key Bindings

| Key | Action | Behavior |
|-----|--------|----------|
| `↑/k` | Previous sibling | Move to previous node at same level |
| `↓/j` | Next sibling | Move to next node at same level |
| `→/l` | Dive | Enter first child of current node |
| `←/h` | Back | Return to parent node |
| `n` | New | Create new child node (modal) |
| `e` | Edit | Edit current node title (modal) |
| `d` | Done | Toggle status (cascades done to children) |
| `x` | Delete | Delete current node and all children |
| `?` | Help | Show key bindings overlay |
| `r` | Refresh | Force redraw |
| `q` | Quit | Auto-save and exit |

---

### Modals

Implemented using OpenTUI `BoxRenderable` and `InputRenderable`.

#### New Sub-Problem Modal

**Trigger:** `n` key

```
┌─────────────────────────────────────┐
│ Create New Sub-Problem              │
├─────────────────────────────────────┤
│  Title: [_________________________] │
│                                     │
│     [Create]     [Cancel]           │
├─────────────────────────────────────┤
│ Tab:next  Enter:create  Esc:cancel  │
└─────────────────────────────────────┘
```

**Fields:**
- **Title** (required): 1–200 characters, trimmed, auto-focused

**Navigation:**
- `Tab/↓` – Next field/button
- `Shift+Tab/↑` – Previous
- `Enter` – Submit (when on Create button or in text field)
- `Esc` – Cancel

**Behavior:**
- Adds node as last child of current node
- Default status: `open`
- Auto-generates UUID and timestamps
- Auto-saves immediately
- Focus moves to the new child

---

#### Edit Problem Modal

**Trigger:** `e` key

Same layout as New modal, titled "Edit Problem".

**Fields:** Pre-filled with current title

**Buttons:**
- `Save` (`Enter`)
- `Cancel` (`Esc`)

**Behavior:**
- Updates title only (cannot edit ID, status, timestamps, or children)
- Auto-saves immediately

---

#### Delete Confirmation Modal

**Trigger:** `x` key

```
┌─────────────────────────────────────┐
│ Delete Problem?                     │
├─────────────────────────────────────┤
│  "Problem Title Here"               │
│                                     │
│  This will delete this problem      │
│  and 5 children permanently.        │
│                                     │
│     [Delete]     [Cancel]           │
├─────────────────────────────────────┤
│ Enter:confirm  Esc:cancel           │
└─────────────────────────────────────┘
```

**Behavior:**
- Shows title of node to be deleted
- Shows count of children that will also be deleted
- Cannot delete root node (show message: "Cannot delete root problem")
- On confirm: Removes node and all descendants, focus moves to previous sibling (or parent if no siblings)
- Auto-saves immediately

---

### Navigation Stack

**Implementation:**
- Array of node IDs representing path from root to current node
- Root always at index 0
- Current node is the last element in the stack

**Operations:**
- **Push (→ dive):** Appends first child's ID to stack
- **Pop (← back):** Removes last entry (minimum length 1, cannot pop past root)
- **Sibling (↑/↓):** Replaces last entry with sibling's ID (stack length unchanged)

**Breadcrumbs:**
- Format: `Root > Parent > Grandparent` (shows path to parent, not current)
- If total >60 characters: `... > Grandparent > Parent`
- Individual segments truncated to 20 characters with ellipsis if needed
- At root level: Shows project name only

---

### OpenTUI Architecture

**Renderer Setup:**
```typescript
import { createCliRenderer, BoxRenderable, TextRenderable } from "@opentui/core"

const renderer = await createCliRenderer({
  consoleOptions: {
    position: ConsolePosition.BOTTOM,
    sizePercent: 20,
    startInDebugMode: false
  }
})

renderer.start()
```

**Component Hierarchy:**
1. **Root Container** (`GroupRenderable`) – Full terminal
2. **Breadcrumb Bar** (`BoxRenderable` + `TextRenderable`) – Path to current node
3. **Current Node Display** (`BoxRenderable`) – Title and status
4. **Children List** (`BoxRenderable`) – Preview of children
5. **Sibling Indicators** (`TextRenderable`) – Above/below context
6. **Key Hints Bar** (`BoxRenderable` + `TextRenderable`) – Available actions
7. **Modal Overlay** (`BoxRenderable`, high z-index) – Input dialogs

**Event Handling:**
```typescript
renderer.keyInput.on("keypress", (key: KeyEvent) => {
  if (modalOpen) {
    handleModalKey(key)
  } else {
    handleNavigationKey(key)
  }
})
```

**Application State:**
```typescript
interface AppState {
  project: Project              // Loaded project JSON (source of truth)
  navigationStack: string[]     // Array of node IDs from root to current
  modalState: ModalState | null // Active modal or null
  feedbackMessage: string | null // Temporary edge feedback
}
```

**State Derivations:**
- Current node: Last ID in navigation stack → lookup in tree
- Parent node: Second-to-last ID in navigation stack
- Siblings: Parent's children array
- Current index: Position of current node in siblings array

---

### Edge Cases

| Scenario | Behavior |
|----------|----------|
| Root with no children | Show: `No sub-problems yet. Press 'n' to add one.` |
| Node with no children | Children section shows: `No sub-problems yet. Press 'n' to add one.` |
| Press `→` with no children | Feedback: `No children` |
| Press `←` at root | Feedback: `Already at root` |
| Press `↑` at first sibling | Feedback: `No previous sibling` |
| Press `↓` at last sibling | Feedback: `No next sibling` |
| Only child, press `↑/↓` | Feedback: `No siblings` |
| Press `x` on root node | Feedback: `Cannot delete root problem` |
| Title >200 characters | Modal validation prevents submission |
| Whitespace-only title | Validation error: `Title cannot be empty` |
| Deep nesting (>10 levels) | Fully supported with breadcrumb truncation |
| Wide tree (>100 children) | Scrollable children list with indicators |
| Terminal resize | Handled automatically by OpenTUI/Yoga layout |
| Corrupted JSON | Error: `Project file corrupted. Please restore backup.` |
| Missing file during session | Graceful save failure with error message |
| Concurrent edits | Not supported – last write wins |
| Mark done with children | All descendants also marked done (cascade) |
| Delete node with children | All descendants also deleted (after confirmation) |

---

### Visual Styling

**Status Badges:**
- `[OPEN]` – Default/white color
- `[DONE]` – Green (#00FF00)

**Children List Markers:**
- `• [ ]` – Open child (default)
- `• [x]` – Done child (dim/gray)

**Sibling Indicators:**
- `↑ Sibling Title` – Previous sibling exists
- `↓ Sibling Title` – Next sibling exists

**Feedback Messages:**
- Temporary toast/flash for edge conditions
- Duration: ~1.5 seconds, then fade

**Color Palette:**
```typescript
const colors = {
  breadcrumbs: RGBA.fromHex("#888888"),
  currentTitle: RGBA.fromHex("#FFFFFF"),
  statusOpen: RGBA.fromHex("#FFFFFF"),
  statusDone: RGBA.fromHex("#00FF00"),
  childrenText: RGBA.fromHex("#CCCCCC"),
  siblingHint: RGBA.fromHex("#888888"),
  keyHints: RGBA.fromHex("#888888"),
  border: RGBA.fromHex("#666666"),
  feedback: RGBA.fromHex("#FFAA00") // Warning/info color
}
```

**Box Styling:**
- Border: single or rounded
- Padding: 1 cell
- Current node section: prominent/highlighted

---

## Persistence

**Save Triggers (Auto-save on every change):**
- Creating a new sub-problem
- Editing a node title
- Toggling status (including cascade to children)
- Deleting a node
- Application exit

**Save Implementation:**
```typescript
async function saveProject(project: Project): Promise<void> {
  project.modified_at = new Date().toISOString()
  const json = JSON.stringify(project, null, 2)
  const tempPath = `${projectPath}.tmp`
  await Bun.write(tempPath, json)
  await Bun.rename(tempPath, projectPath) // Atomic
}
```

**Load Implementation:**
```typescript
async function loadProject(name: string): Promise<Project> {
  const path = getProjectPath(name) // Platform-specific path
  const file = Bun.file(path)
  if (!await file.exists()) throw new Error("Project not found")
  const project = await file.json()
  validateProjectSchema(project)
  return project
}
```

**Status Cascade Implementation:**
```typescript
function markNodeDone(node: Node): void {
  node.status = "done"
  node.completed_at = new Date().toISOString()
  // Recursively mark all descendants as done
  for (const child of node.children) {
    markNodeDone(child)
  }
}

function markNodeOpen(node: Node): void {
  // Only marks the single node as open, no cascade
  node.status = "open"
  node.completed_at = null
}
```

**Error Handling:**
- Write failure: Show error toast, offer retry or quit without saving
- Read failure: Show error and exit cleanly

---

## Validation

**Project Name:**
```typescript
function isValidProjectName(name: string): boolean {
  if (name.length < 1 || name.length > 50) return false
  if (!/^[a-zA-Z0-9]/.test(name)) return false
  if (!/^[a-zA-Z0-9_-]+$/.test(name)) return false
  const reserved = ['list', 'new', 'delete', 'open', 'tree', 'help', 'version']
  if (reserved.includes(name.toLowerCase())) return false
  return true
}
```

**Node Title:**
```typescript
function isValidTitle(title: string): boolean {
  const trimmed = title.trim()
  if (trimmed.length < 1 || trimmed.length > 200) return false
  return true
}
```

---

## Platform Utilities

**Data Directory:**
```typescript
import { homedir, platform } from "os"
import { join } from "path"

function getDataDir(): string {
  switch (platform()) {
    case "darwin":
      return join(homedir(), "Library", "Application Support")
    case "win32":
      return process.env.APPDATA || join(homedir(), "AppData", "Roaming")
    default: // Linux and others
      return process.env.XDG_DATA_HOME || join(homedir(), ".local", "share")
  }
}

function getProjectsDir(): string {
  return join(getDataDir(), "depthfirst", "projects")
}

function getProjectPath(name: string): string {
  return join(getProjectsDir(), `${name.toLowerCase()}.json`)
}
```

---

## Error Messages

### CLI Errors

| Error | Message |
|-------|---------|
| Name too short | `Project name must be at least 1 character long.` |
| Name too long | `Project name must be 50 characters or less.` |
| Invalid characters | `Project name can only contain letters, numbers, hyphens, and underscores.` |
| Reserved name | `'{name}' is a reserved name. Please choose another.` |
| Project exists | `Project '{name}' already exists. Use 'dft open {name}' to work on it.` |
| Project not found | `Project '{name}' not found. Use 'dft list' to see available projects.` |
| Corrupted file | `Project file is corrupted and cannot be loaded.` |
| Permission error | `Cannot write to project directory. Check permissions.` |

### TUI Validation Errors

| Error | Message |
|-------|---------|
| Title too short | `Title must be at least 1 character long.` |
| Title too long | `Title must be 200 characters or less.` |
| Whitespace title | `Title cannot be empty or contain only whitespace.` |

### TUI Navigation Feedback

| Condition | Message |
|-----------|---------|
| No previous sibling | `No previous sibling` |
| No next sibling | `No next sibling` |
| No siblings at all | `No siblings` |
| No children | `No children` |
| Already at root | `Already at root` |
| Cannot delete root | `Cannot delete root problem` |

---

## Project Structure

```
dft/
├── src/
│   ├── index.ts              # CLI entry point
│   ├── commands/
│   │   ├── new.ts            # dft new
│   │   ├── list.ts           # dft list
│   │   ├── delete.ts         # dft delete
│   │   ├── open.ts           # dft open (TUI launcher)
│   │   └── tree.ts           # dft tree
│   ├── tui/
│   │   ├── app.ts            # Main OpenTUI app
│   │   ├── renderer.ts       # UI rendering logic
│   │   ├── navigation.ts     # Navigation stack management
│   │   ├── modals.ts         # Modal components (new, edit, delete)
│   │   └── components.ts     # Reusable UI components
│   ├── data/
│   │   ├── types.ts          # Project and Node types
│   │   ├── storage.ts        # File I/O (load, save)
│   │   └── operations.ts     # Tree operations (add, edit, delete, toggle)
│   └── utils/
│       ├── validation.ts     # Validation logic
│       ├── platform.ts       # Cross-platform paths
│       └── formatting.ts     # Display formatting (breadcrumbs, truncation)
├── package.json
├── tsconfig.json
└── bunfig.toml
```

---

## Dependencies

```json
{
  "dependencies": {
    "@opentui/core": "latest",
    "commander": "^11.0.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/uuid": "^9.0.0",
    "bun-types": "latest"
  }
}
```

---

## Build & Installation

**Development:**
```bash
bun install
bun run src/index.ts new test-project "Test Problem"
bun run src/index.ts open test-project
```

**Build:**
```bash
bun build src/index.ts --compile --outfile dft
```

**Global Install:**
```bash
bun link
# 'dft' command now available globally
```

---

## Tree Operations

### Add Child Node
```typescript
function addChildNode(parent: Node, title: string): Node {
  const newNode: Node = {
    id: crypto.randomUUID(),
    title: title.trim(),
    status: "open",
    children: [],
    created_at: new Date().toISOString(),
    completed_at: null
  }
  parent.children.push(newNode)
  return newNode
}
```

### Delete Node
```typescript
function deleteNode(parent: Node, nodeId: string): boolean {
  const index = parent.children.findIndex(c => c.id === nodeId)
  if (index === -1) return false
  parent.children.splice(index, 1)
  return true
}

function countDescendants(node: Node): number {
  let count = node.children.length
  for (const child of node.children) {
    count += countDescendants(child)
  }
  return count
}
```

### Find Node by ID
```typescript
function findNode(root: Node, id: string): Node | null {
  if (root.id === id) return root
  for (const child of root.children) {
    const found = findNode(child, id)
    if (found) return found
  }
  return null
}

function findParent(root: Node, childId: string): Node | null {
  for (const child of root.children) {
    if (child.id === childId) return root
    const found = findParent(child, childId)
    if (found) return found
  }
  return null
}
```

### Build Path to Node
```typescript
function buildPathToNode(root: Node, targetId: string): string[] | null {
  if (root.id === targetId) return [root.id]
  for (const child of root.children) {
    const path = buildPathToNode(child, targetId)
    if (path) return [root.id, ...path]
  }
  return null
}
```

---

## Implementation Notes

1. **Atomic Saves:** Using a temporary file and rename ensures crash safety.
2. **Navigation:** A stack-based path provides O(1) access to the parent.
3. **Rendering:** OpenTUI's Yoga layout handles terminal resizing.
4. **Validation:** All input is validated before any state changes.
5. **State Management:** A single project JSON serves as the source of truth.
6. **Keyboard Handling:** Event-driven, with no polling.
7. **Status Cascade:** The "done" status propagates automatically to all descendants.
8. **Concurrency:** Not supported in the MVP — last write wins.
9. **Linting:** Use Biome as a linter.
10. **Testing:** Perform a small test for each part.
